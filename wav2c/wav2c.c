/*////////////////////////////////////////////////////////////////////////////
// wav2c.c                                                                  //
////////////////////////////////////////////////////////////////////////////*/
/*
    Converts a wave file to a C include and header file for use with the GBA.
    by Matt Bigelow
    v1.0
*/


/*////////////////////////////////////////////////////////////////////////////
// Includes                                                                 //
////////////////////////////////////////////////////////////////////////////*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/*////////////////////////////////////////////////////////////////////////////
// Defines                                                                  //
////////////////////////////////////////////////////////////////////////////*/
#define NAME            "wav2c"
#define VER             "1.0"
#define CHARS_PER_LINE  16
#define BUFSIZE         4096
#define NAME_MAX        255

#define EXIT(code) \
    { if(outc) free(outc); if(outh) free(outh); if(name) free(name); \
        if(code) { printf("Press any key to continue..."); getc(stdin); } \
        return (code); }
#define DOWAVE_EXIT(code) \
    { if(fi) fclose(fi); if(foc) fclose(foc); if(foh) fclose(foh); \
        return (code); }
#define SZCH sizeof(char)

/*////////////////////////////////////////////////////////////////////////////
// typedefs                                                                 //
////////////////////////////////////////////////////////////////////////////*/
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;

typedef struct
{
    char    riff_id[4]; /* "RIFF" */
    u32        riff_len;

        char    wave_id[4]; /* "WAVE" */

        char    fmt_id[4]; /* "fmt " */
        u32     fmt_len;
            u16        fmt_tag;
            u16        channels; /* 1=mono, 2=stereo */
            u32        samplerate;
            u32        samplerate2;
            u16        u8s_per_sample;
            u16        bits; /* 8/16 bits */

        char    data_id[4]; /* "data" */
        u32     data_len;
} WaveHdr;

/*////////////////////////////////////////////////////////////////////////////
// printHeaders                                                             //
////////////////////////////////////////////////////////////////////////////*/
void printHeaders(WaveHdr *hdr, char *inwav, FILE *fi, FILE *foc, FILE *foh,
                    char *name, char *q)
{
    char hbuff[2048];
    unsigned int size;
    time_t rawtime;
    int i, l;

    time(&rawtime);

    /* create varible name (take out invalid characters) */
    strncpy(q, name, SZCH*(NAME_MAX-2)); q[SZCH*(NAME_MAX-1)] = '\0';
    l=strlen(q);
    for(i=0; i<l; i++) {
        if((q[i]>='a') && (q[i]<='z')) q[i]+='A'-'a';
        if(((q[i]<'A') || (q[i]>'Z')) && ((q[i]<'0') || (q[i]>'9'))) q[i]='_';
    }
    l=strlen(name);
    for(i=0; i<l; i++)
        if(((name[i]<'A') || (name[i]>'Z')) &&
           ((name[i]<'a') || (name[i]>'z')) &&
           ((name[i]<'0') || (name[i]>'9')))
            name[i]='_';

    fseek(fi, 0, SEEK_END);
    size = hdr->data_len / hdr->channels;

    /* output header text to files */
    sprintf(hbuff, "\n"
        "/**************************************************************\n"
        " *\t\n"
        " *\t%s, %u bit, %uHz,\n"
        " *\t%u channel, %u bytes/channel\n"
        " *\tTotal Size: %u * %u + %u (header) = %u bytes\n"
        " *\t\n"
        " *\tGenerated by "NAME" v"VER" from:\n"
        " *\t%s\n"
        " *\tTime-stamp: %s"
        " *\t\n"
        " **************************************************************/\n",
        name, hdr->bits, (unsigned int)hdr->samplerate,
        hdr->channels, size,
        hdr->channels, size, sizeof(hdr), (unsigned int)ftell(fi),
        inwav,
        asctime(localtime(&rawtime)));
    fputs(hbuff, foc);
    fputs(hbuff, foh);
    fputs("\n", foh);
    fprintf(foh, "#ifndef __%sH__\n", q);
    fprintf(foh, "#define __%sH__\n\n", q);
    fprintf(foh, "#define %sFREQ %u\n", q, (unsigned int)(hdr->samplerate));
    fprintf(foh, "#define %sLEN %u\n\n", q, size);
}

/*////////////////////////////////////////////////////////////////////////////
// DoChannel                                                                //
////////////////////////////////////////////////////////////////////////////*/
int DoChannel(WaveHdr *hdr, FILE *fi, FILE *foc, FILE *foh, char *name,
                char *inname, int channels, int channel)
{
    char buf[BUFSIZE], elem[5];
    size_t s = sizeof buf;
    int i, j=0, size = hdr->data_len / channels;

    /* print out variable info based on number of channels */
    if(channels > 1) {
        fprintf(foc, "\nconst unsigned char %s_c%d[%d] = {\n", name, channel+1,
            size);
        fprintf(foh, "extern const unsigned char %s_c%d[%d];\n", name,
            channel+1, size);
    } else {
        fprintf(foc, "\nconst unsigned char %s[%d] = {\n", name, size);
        fprintf(foh, "extern const unsigned char %s[%d];\n", name, size);
    }

    /* seek to the input file's data section (usually 44 bytes in ) */
    fseek(fi, sizeof(*hdr), SEEK_SET);

    /* read the input file and convert the binary data to a text hex table */
    while((s = fread(buf, 1, s, fi)))
        for(i = channel-(BUFSIZE%channels); i < s; i+=channels, j++) {
            if(j % CHARS_PER_LINE == 0)
                fputs("\t", foc);
            sprintf(elem, "0x%02X", buf[i]+0x80);
            fputs(elem, foc);
            if(j+1 < size) {
                fputs(",", foc);
                if ((j+1) % CHARS_PER_LINE == 0)
                    fputs("\n", foc);
            } else
                fputs("\n", foc);
        }

    fputs("};\n", foc);

    return 0;
}

/*////////////////////////////////////////////////////////////////////////////
// DoWave                                                                   //
////////////////////////////////////////////////////////////////////////////*/
int DoWave(char *inwav, char *outc, char *outh, char *name)
{
    char q[NAME_MAX];
    int channel;
    FILE *fi=NULL, *foc=NULL, *foh=NULL;
    WaveHdr hdr;

    /* open input file */
    if(!(fi = fopen(inwav, "rb")))
        { printf("Error opening input file!\n"); DOWAVE_EXIT(-1); }

    /* read header and check to see if this is a valid file */
    fread(&hdr, sizeof(hdr), 1, fi);
    if(strncmp(hdr.riff_id, "RIFF", 4))
        { printf("Error: 'WAVE' not found\n"); DOWAVE_EXIT(-1); }
    if(strncmp(hdr.wave_id, "WAVE", 4))
        { printf("Error: 'WAVE' not found\n"); DOWAVE_EXIT(-1); }
    if(strncmp(hdr.fmt_id, "fmt ", 4))
        { printf("Error: 'fmt ' not found\n"); DOWAVE_EXIT(-1); }
    if(strncmp(hdr.data_id, "data", 4))
        { printf("Error: 'data' not found\n"); DOWAVE_EXIT(-1); }
    if(hdr.bits != 8)
        { printf("Error: 8 bit required\n"); DOWAVE_EXIT(-1); }

    /* open output files */
    if(!(foc = fopen(outc, "w")))
        { printf("Error opening C output file!\n"); DOWAVE_EXIT(-1); }
    if(!(foh = fopen(outh, "w")))
        { printf("Error opening H output file!\n"); DOWAVE_EXIT(-1); }

    /* print the headers to the output files */
    printHeaders(&hdr, inwav, fi, foc, foh, name, q);

    /* process channels */
    for(channel=0; channel<hdr.channels; channel++)
        if(DoChannel(&hdr, fi, foc, foh, name, inwav, hdr.channels, channel))
            DOWAVE_EXIT(-1);

    /* output footer text */
    fprintf(foh, "\n#endif /* __%sH__ */\n", q);

    DOWAVE_EXIT(0);
}

/*////////////////////////////////////////////////////////////////////////////
// main                                                                     //
////////////////////////////////////////////////////////////////////////////*/
int main(int argc, char *argv[])
{
    char *inwav=NULL, *outc=NULL, *outh=NULL, *name=NULL, *fns=NULL;
    int len, ext;

    /* display syntax if no input file given */
    if (argc < 2) {
        printf(NAME" v"VER" by Matt Bigelow\n");
        printf("Syntax: "NAME" <infile.wav>\n");
        EXIT(1);
    }

    /* determine character positioning for input file -
       total length, extension size, file name start position */
    inwav = argv[1];
    len = strlen(inwav);
    ext = strrchr(inwav, '.')?(inwav + SZCH*len - strrchr(inwav, '.')):0;
    fns = strrchr(inwav, '/')?strrchr(inwav, '/')+SZCH:(strrchr(inwav, '\\')?
        strrchr(inwav, '\\')+SZCH:inwav);

    /* allocate memory for output file names and variable name */
    if(!(outc = malloc(SZCH*(len - ext + 3))))
        { printf("Error: Out of memory\n"); EXIT(-1); }
    if(!(outh = malloc(SZCH*(len - ext + 3))))
        { printf("Error: Out of memory\n"); EXIT(-1); }
    if(!(name = malloc((inwav + SZCH*len - fns - SZCH*ext + SZCH))))
        { printf("Error: Out of memory\n"); EXIT(-1); }

    /* copy over appropriate information from input filename */
    strncpy(outc, inwav, SZCH*(len - ext)); outc[SZCH*(len - ext)] = '\0';
    strncpy(outh, inwav, SZCH*(len - ext)); outh[SZCH*(len - ext)] = '\0';
    strncpy(name, fns, inwav + SZCH*len - fns - SZCH*ext);
    name[inwav + SZCH*len - fns - SZCH*ext] = '\0';
    strcat(outc, ".c"); strcat(outh, ".h");

    /* process the input file */
    if(DoWave(inwav, outc, outh, name)) EXIT(-1);

    EXIT(0);
}
